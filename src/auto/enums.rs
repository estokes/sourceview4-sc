// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceBackgroundPatternType")]
pub enum BackgroundPatternType {
    #[doc(alias = "GTK_SOURCE_BACKGROUND_PATTERN_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_BACKGROUND_PATTERN_TYPE_GRID")]
    Grid,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BackgroundPatternType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BackgroundPatternType::{}",
            match *self {
                Self::None => "None",
                Self::Grid => "Grid",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for BackgroundPatternType {
    type GlibType = ffi::GtkSourceBackgroundPatternType;

    fn into_glib(self) -> ffi::GtkSourceBackgroundPatternType {
        match self {
            Self::None => ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_NONE,
            Self::Grid => ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_GRID,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceBackgroundPatternType> for BackgroundPatternType {
    unsafe fn from_glib(value: ffi::GtkSourceBackgroundPatternType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_NONE => Self::None,
            ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_GRID => Self::Grid,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for BackgroundPatternType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_background_pattern_type_get_type()) }
    }
}

impl glib::value::ValueType for BackgroundPatternType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BackgroundPatternType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BackgroundPatternType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceBracketMatchType")]
pub enum BracketMatchType {
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_OUT_OF_RANGE")]
    OutOfRange,
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_NOT_FOUND")]
    NotFound,
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_FOUND")]
    Found,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BracketMatchType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BracketMatchType::{}",
            match *self {
                Self::None => "None",
                Self::OutOfRange => "OutOfRange",
                Self::NotFound => "NotFound",
                Self::Found => "Found",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for BracketMatchType {
    type GlibType = ffi::GtkSourceBracketMatchType;

    fn into_glib(self) -> ffi::GtkSourceBracketMatchType {
        match self {
            Self::None => ffi::GTK_SOURCE_BRACKET_MATCH_NONE,
            Self::OutOfRange => ffi::GTK_SOURCE_BRACKET_MATCH_OUT_OF_RANGE,
            Self::NotFound => ffi::GTK_SOURCE_BRACKET_MATCH_NOT_FOUND,
            Self::Found => ffi::GTK_SOURCE_BRACKET_MATCH_FOUND,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceBracketMatchType> for BracketMatchType {
    unsafe fn from_glib(value: ffi::GtkSourceBracketMatchType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_BRACKET_MATCH_NONE => Self::None,
            ffi::GTK_SOURCE_BRACKET_MATCH_OUT_OF_RANGE => Self::OutOfRange,
            ffi::GTK_SOURCE_BRACKET_MATCH_NOT_FOUND => Self::NotFound,
            ffi::GTK_SOURCE_BRACKET_MATCH_FOUND => Self::Found,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for BracketMatchType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_bracket_match_type_get_type()) }
    }
}

impl glib::value::ValueType for BracketMatchType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BracketMatchType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BracketMatchType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceChangeCaseType")]
pub enum ChangeCaseType {
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_LOWER")]
    Lower,
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_UPPER")]
    Upper,
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_TOGGLE")]
    Toggle,
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_TITLE")]
    Title,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ChangeCaseType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ChangeCaseType::{}",
            match *self {
                Self::Lower => "Lower",
                Self::Upper => "Upper",
                Self::Toggle => "Toggle",
                Self::Title => "Title",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ChangeCaseType {
    type GlibType = ffi::GtkSourceChangeCaseType;

    fn into_glib(self) -> ffi::GtkSourceChangeCaseType {
        match self {
            Self::Lower => ffi::GTK_SOURCE_CHANGE_CASE_LOWER,
            Self::Upper => ffi::GTK_SOURCE_CHANGE_CASE_UPPER,
            Self::Toggle => ffi::GTK_SOURCE_CHANGE_CASE_TOGGLE,
            Self::Title => ffi::GTK_SOURCE_CHANGE_CASE_TITLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceChangeCaseType> for ChangeCaseType {
    unsafe fn from_glib(value: ffi::GtkSourceChangeCaseType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_CHANGE_CASE_LOWER => Self::Lower,
            ffi::GTK_SOURCE_CHANGE_CASE_UPPER => Self::Upper,
            ffi::GTK_SOURCE_CHANGE_CASE_TOGGLE => Self::Toggle,
            ffi::GTK_SOURCE_CHANGE_CASE_TITLE => Self::Title,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ChangeCaseType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_change_case_type_get_type()) }
    }
}

impl glib::value::ValueType for ChangeCaseType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ChangeCaseType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ChangeCaseType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceCompletionError")]
pub enum CompletionError {
    #[doc(alias = "GTK_SOURCE_COMPLETION_ERROR_ALREADY_BOUND")]
    AlreadyBound,
    #[doc(alias = "GTK_SOURCE_COMPLETION_ERROR_NOT_BOUND")]
    NotBound,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CompletionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CompletionError::{}",
            match *self {
                Self::AlreadyBound => "AlreadyBound",
                Self::NotBound => "NotBound",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for CompletionError {
    type GlibType = ffi::GtkSourceCompletionError;

    fn into_glib(self) -> ffi::GtkSourceCompletionError {
        match self {
            Self::AlreadyBound => ffi::GTK_SOURCE_COMPLETION_ERROR_ALREADY_BOUND,
            Self::NotBound => ffi::GTK_SOURCE_COMPLETION_ERROR_NOT_BOUND,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceCompletionError> for CompletionError {
    unsafe fn from_glib(value: ffi::GtkSourceCompletionError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_COMPLETION_ERROR_ALREADY_BOUND => Self::AlreadyBound,
            ffi::GTK_SOURCE_COMPLETION_ERROR_NOT_BOUND => Self::NotBound,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for CompletionError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_source_completion_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            ffi::GTK_SOURCE_COMPLETION_ERROR_ALREADY_BOUND => Some(Self::AlreadyBound),
            ffi::GTK_SOURCE_COMPLETION_ERROR_NOT_BOUND => Some(Self::NotBound),
            value => Some(Self::__Unknown(value)),
        }
    }
}

impl StaticType for CompletionError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_completion_error_get_type()) }
    }
}

impl glib::value::ValueType for CompletionError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CompletionError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CompletionError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceCompressionType")]
pub enum CompressionType {
    #[doc(alias = "GTK_SOURCE_COMPRESSION_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_COMPRESSION_TYPE_GZIP")]
    Gzip,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CompressionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CompressionType::{}",
            match *self {
                Self::None => "None",
                Self::Gzip => "Gzip",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for CompressionType {
    type GlibType = ffi::GtkSourceCompressionType;

    fn into_glib(self) -> ffi::GtkSourceCompressionType {
        match self {
            Self::None => ffi::GTK_SOURCE_COMPRESSION_TYPE_NONE,
            Self::Gzip => ffi::GTK_SOURCE_COMPRESSION_TYPE_GZIP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceCompressionType> for CompressionType {
    unsafe fn from_glib(value: ffi::GtkSourceCompressionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_COMPRESSION_TYPE_NONE => Self::None,
            ffi::GTK_SOURCE_COMPRESSION_TYPE_GZIP => Self::Gzip,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CompressionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_compression_type_get_type()) }
    }
}

impl glib::value::ValueType for CompressionType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CompressionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CompressionType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceFileLoaderError")]
pub enum FileLoaderError {
    #[doc(alias = "GTK_SOURCE_FILE_LOADER_ERROR_TOO_BIG")]
    TooBig,
    #[doc(alias = "GTK_SOURCE_FILE_LOADER_ERROR_ENCODING_AUTO_DETECTION_FAILED")]
    EncodingAutoDetectionFailed,
    #[doc(alias = "GTK_SOURCE_FILE_LOADER_ERROR_CONVERSION_FALLBACK")]
    ConversionFallback,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileLoaderError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileLoaderError::{}",
            match *self {
                Self::TooBig => "TooBig",
                Self::EncodingAutoDetectionFailed => "EncodingAutoDetectionFailed",
                Self::ConversionFallback => "ConversionFallback",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FileLoaderError {
    type GlibType = ffi::GtkSourceFileLoaderError;

    fn into_glib(self) -> ffi::GtkSourceFileLoaderError {
        match self {
            Self::TooBig => ffi::GTK_SOURCE_FILE_LOADER_ERROR_TOO_BIG,
            Self::EncodingAutoDetectionFailed => {
                ffi::GTK_SOURCE_FILE_LOADER_ERROR_ENCODING_AUTO_DETECTION_FAILED
            }
            Self::ConversionFallback => ffi::GTK_SOURCE_FILE_LOADER_ERROR_CONVERSION_FALLBACK,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceFileLoaderError> for FileLoaderError {
    unsafe fn from_glib(value: ffi::GtkSourceFileLoaderError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_FILE_LOADER_ERROR_TOO_BIG => Self::TooBig,
            ffi::GTK_SOURCE_FILE_LOADER_ERROR_ENCODING_AUTO_DETECTION_FAILED => {
                Self::EncodingAutoDetectionFailed
            }
            ffi::GTK_SOURCE_FILE_LOADER_ERROR_CONVERSION_FALLBACK => Self::ConversionFallback,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for FileLoaderError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_source_file_loader_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            ffi::GTK_SOURCE_FILE_LOADER_ERROR_TOO_BIG => Some(Self::TooBig),
            ffi::GTK_SOURCE_FILE_LOADER_ERROR_ENCODING_AUTO_DETECTION_FAILED => {
                Some(Self::EncodingAutoDetectionFailed)
            }
            ffi::GTK_SOURCE_FILE_LOADER_ERROR_CONVERSION_FALLBACK => Some(Self::ConversionFallback),
            value => Some(Self::__Unknown(value)),
        }
    }
}

impl StaticType for FileLoaderError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_file_loader_error_get_type()) }
    }
}

impl glib::value::ValueType for FileLoaderError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FileLoaderError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileLoaderError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceFileSaverError")]
pub enum FileSaverError {
    #[doc(alias = "GTK_SOURCE_FILE_SAVER_ERROR_INVALID_CHARS")]
    InvalidChars,
    #[doc(alias = "GTK_SOURCE_FILE_SAVER_ERROR_EXTERNALLY_MODIFIED")]
    ExternallyModified,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileSaverError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileSaverError::{}",
            match *self {
                Self::InvalidChars => "InvalidChars",
                Self::ExternallyModified => "ExternallyModified",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FileSaverError {
    type GlibType = ffi::GtkSourceFileSaverError;

    fn into_glib(self) -> ffi::GtkSourceFileSaverError {
        match self {
            Self::InvalidChars => ffi::GTK_SOURCE_FILE_SAVER_ERROR_INVALID_CHARS,
            Self::ExternallyModified => ffi::GTK_SOURCE_FILE_SAVER_ERROR_EXTERNALLY_MODIFIED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceFileSaverError> for FileSaverError {
    unsafe fn from_glib(value: ffi::GtkSourceFileSaverError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_FILE_SAVER_ERROR_INVALID_CHARS => Self::InvalidChars,
            ffi::GTK_SOURCE_FILE_SAVER_ERROR_EXTERNALLY_MODIFIED => Self::ExternallyModified,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for FileSaverError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_source_file_saver_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            ffi::GTK_SOURCE_FILE_SAVER_ERROR_INVALID_CHARS => Some(Self::InvalidChars),
            ffi::GTK_SOURCE_FILE_SAVER_ERROR_EXTERNALLY_MODIFIED => Some(Self::ExternallyModified),
            value => Some(Self::__Unknown(value)),
        }
    }
}

impl StaticType for FileSaverError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_file_saver_error_get_type()) }
    }
}

impl glib::value::ValueType for FileSaverError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FileSaverError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileSaverError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceGutterRendererAlignmentMode")]
pub enum GutterRendererAlignmentMode {
    #[doc(alias = "GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_CELL")]
    Cell,
    #[doc(alias = "GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_FIRST")]
    First,
    #[doc(alias = "GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_LAST")]
    Last,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for GutterRendererAlignmentMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "GutterRendererAlignmentMode::{}",
            match *self {
                Self::Cell => "Cell",
                Self::First => "First",
                Self::Last => "Last",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for GutterRendererAlignmentMode {
    type GlibType = ffi::GtkSourceGutterRendererAlignmentMode;

    fn into_glib(self) -> ffi::GtkSourceGutterRendererAlignmentMode {
        match self {
            Self::Cell => ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_CELL,
            Self::First => ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_FIRST,
            Self::Last => ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_LAST,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceGutterRendererAlignmentMode> for GutterRendererAlignmentMode {
    unsafe fn from_glib(value: ffi::GtkSourceGutterRendererAlignmentMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_CELL => Self::Cell,
            ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_FIRST => Self::First,
            ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_LAST => Self::Last,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for GutterRendererAlignmentMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_gutter_renderer_alignment_mode_get_type()) }
    }
}

impl glib::value::ValueType for GutterRendererAlignmentMode {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for GutterRendererAlignmentMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for GutterRendererAlignmentMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceNewlineType")]
pub enum NewlineType {
    #[doc(alias = "GTK_SOURCE_NEWLINE_TYPE_LF")]
    Lf,
    #[doc(alias = "GTK_SOURCE_NEWLINE_TYPE_CR")]
    Cr,
    #[doc(alias = "GTK_SOURCE_NEWLINE_TYPE_CR_LF")]
    CrLf,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NewlineType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NewlineType::{}",
            match *self {
                Self::Lf => "Lf",
                Self::Cr => "Cr",
                Self::CrLf => "CrLf",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for NewlineType {
    type GlibType = ffi::GtkSourceNewlineType;

    fn into_glib(self) -> ffi::GtkSourceNewlineType {
        match self {
            Self::Lf => ffi::GTK_SOURCE_NEWLINE_TYPE_LF,
            Self::Cr => ffi::GTK_SOURCE_NEWLINE_TYPE_CR,
            Self::CrLf => ffi::GTK_SOURCE_NEWLINE_TYPE_CR_LF,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceNewlineType> for NewlineType {
    unsafe fn from_glib(value: ffi::GtkSourceNewlineType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_NEWLINE_TYPE_LF => Self::Lf,
            ffi::GTK_SOURCE_NEWLINE_TYPE_CR => Self::Cr,
            ffi::GTK_SOURCE_NEWLINE_TYPE_CR_LF => Self::CrLf,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for NewlineType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_newline_type_get_type()) }
    }
}

impl glib::value::ValueType for NewlineType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for NewlineType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NewlineType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceSmartHomeEndType")]
pub enum SmartHomeEndType {
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_DISABLED")]
    Disabled,
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_BEFORE")]
    Before,
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_AFTER")]
    After,
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_ALWAYS")]
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SmartHomeEndType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SmartHomeEndType::{}",
            match *self {
                Self::Disabled => "Disabled",
                Self::Before => "Before",
                Self::After => "After",
                Self::Always => "Always",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SmartHomeEndType {
    type GlibType = ffi::GtkSourceSmartHomeEndType;

    fn into_glib(self) -> ffi::GtkSourceSmartHomeEndType {
        match self {
            Self::Disabled => ffi::GTK_SOURCE_SMART_HOME_END_DISABLED,
            Self::Before => ffi::GTK_SOURCE_SMART_HOME_END_BEFORE,
            Self::After => ffi::GTK_SOURCE_SMART_HOME_END_AFTER,
            Self::Always => ffi::GTK_SOURCE_SMART_HOME_END_ALWAYS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceSmartHomeEndType> for SmartHomeEndType {
    unsafe fn from_glib(value: ffi::GtkSourceSmartHomeEndType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_SMART_HOME_END_DISABLED => Self::Disabled,
            ffi::GTK_SOURCE_SMART_HOME_END_BEFORE => Self::Before,
            ffi::GTK_SOURCE_SMART_HOME_END_AFTER => Self::After,
            ffi::GTK_SOURCE_SMART_HOME_END_ALWAYS => Self::Always,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SmartHomeEndType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_smart_home_end_type_get_type()) }
    }
}

impl glib::value::ValueType for SmartHomeEndType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SmartHomeEndType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SmartHomeEndType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceViewGutterPosition")]
pub enum ViewGutterPosition {
    #[doc(alias = "GTK_SOURCE_VIEW_GUTTER_POSITION_LINES")]
    Lines,
    #[doc(alias = "GTK_SOURCE_VIEW_GUTTER_POSITION_MARKS")]
    Marks,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ViewGutterPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ViewGutterPosition::{}",
            match *self {
                Self::Lines => "Lines",
                Self::Marks => "Marks",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ViewGutterPosition {
    type GlibType = ffi::GtkSourceViewGutterPosition;

    fn into_glib(self) -> ffi::GtkSourceViewGutterPosition {
        match self {
            Self::Lines => ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_LINES,
            Self::Marks => ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_MARKS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceViewGutterPosition> for ViewGutterPosition {
    unsafe fn from_glib(value: ffi::GtkSourceViewGutterPosition) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_LINES => Self::Lines,
            ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_MARKS => Self::Marks,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ViewGutterPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_view_gutter_position_get_type()) }
    }
}

impl glib::value::ValueType for ViewGutterPosition {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ViewGutterPosition {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ViewGutterPosition {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
